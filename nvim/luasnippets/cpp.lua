require("luasnip.session.snippet_collection").clear_snippets("all")
local ls = require("luasnip")
local s = ls.snippet
local t = ls.text_node

ls.add_snippets("cpp", {
  s("main", {
    t({
      "#include <bits/stdc++.h>", -- Includes most standard headers
      "using namespace std;",
      "",
      "// Type Aliases",
      "using ll = long long;",
      "using vi = vector<int>;",
      "using vll = vector<ll>;",
      "using vvi = vector<vector<int>>;", -- Alias for 2D int vector
      "using vvll = vector<vector<ll>>;", -- Alias for 2D long long vector
      "using pii = pair<int, int>;",
      "using pll = pair<ll, ll>;",
      "using vpii = vector<pair<int, int>>;",          -- Alias for vector of int pairs
      "using vpll = vector<pair<ll, ll>>;",            -- Alias for vector of ll pairs
      "using vvpii = vector<vector<pair<int, int>>>;", -- Alias for 2D vector of int pairs
      "using vvpll = vector<vector<pair<ll, ll>>>;",   -- Alias for 2D vector of ll pairs
      "",
      "// Macros",
      "#define all(x) x.begin(), x.end()",
      "#define pb push_back",
      "#define mp make_pair", -- Often useful with pairs
      "",
      "// Debugging Setup - Enabled when compiling with -DDEBUG",
      "#ifdef DEBUG",
      "// Helper to check if a type is iterable (has begin() and end())",
      "template<typename T, typename = void>",
      "struct is_iterable : std::false_type { };",
      "template<typename T>",
      "struct is_iterable<T, std::void_t<decltype(begin(std::declval<T>())), decltype(end(std::declval<T>()))>> : std::true_type { };",
      "",
      "// Overload for std::pair",
      "template<typename A, typename B>",
      "ostream& operator<<(ostream &os, const pair<A, B> &p) {",
      "    return os << '(' << p.first << \", \" << p.second << ')';",
      "}",
      "",
      "// Overload for iterable types (vector, set, map, etc.), except std::string",
      "// This works recursively for nested containers (e.g., vector<vector<int>>, vector<vector<pair<int,int>>>)",
      "template<typename T>",
      "typename enable_if<is_iterable<T>::value && !is_same<T, string>::value, ostream&>::type",
      "operator<<(ostream &os, const T &v) {",
      "    os << \"[\";",
      "    bool first = true;",
      "    for (const auto &x : v) {",
      "        if (!first) os << \", \";",
      "        os << x; // Recursively calls the appropriate operator<< for type of x",
      "        first = false;",
      "    }",
      "    os << \"]\";",
      "    return os;",
      "}",
      "",
      "// Base case for debug_out recursion (handles empty debug() call)",
      "void debug_out() { cerr << \"\\n\"; }",
      "",
      "// Recursive variadic template for printing multiple arguments",
      "template<typename Head, typename... Tail>",
      "void debug_out(Head H, Tail... T) {",
      "    cerr << H; // Print the current argument",
      "    if(sizeof...(T) > 0) cerr << \" \"; // Add space only if more arguments follow",
      "    debug_out(T...); // Recurse for remaining arguments",
      "}",
      "",
      "// The debug macro: prints variable names and values",
      "// Example: debug(x, y, vec); -> prints \"[x, y, vec] = value_of_x value_of_y [elements_of_vec]\"",
      "#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"] = \"; debug_out(__VA_ARGS__)",
      "#else",
      "// If DEBUG is not defined, debug calls do nothing",
      "#define debug(...)",
      "#endif",
      "",
      "void solve() {",
      "    // Placeholder for solution logic",
      "}",
      "",
      "signed main() {",
      "    // Fast I/O",
      "    ios_base::sync_with_stdio(false);",
      "    cin.tie(nullptr);",
      "",
      "    // Optional: Handle multiple test cases",
      "    // int t = 1;",
      "    // cin >> t;",
      "    // while(t--) {",
      "    //    solve();",
      "    // }",
      "",
      "    // Single test case",
      "    solve();",
      "",
      "    return 0;",
      "}"
    }),
  }),
})
